== GStreamer 0.11 / 1.0 ==

This page is a somewhat random collection of things to look at for 0.11. More can be found in gstreamer/docs/random/, gstreamer/docs/design/ and FIXME-0.11 comments inside the sources.

"0.11" describes a future development version of GStreamer where API and ABI changes can (and will) happen. There is no timeline yet for when 0.11 will happen. There is still a lot more that can be achieved with the current 0.10 API.

It is expected that the transition from 0.10 to 0.11/0.12 will be much easier on application and plugin developers than the transition from 0.8 to 0.10 was.

=== GStreamer 1.0 "summit" ===

There was a meeting discussing Gstreamer 1.0 at the Gran Canaria Desktop Summit in July 2009. Thomas took some notes which can be found here: [[GStreamerSummitGranCanaria2009Notes|GStreamer summit notes]]


=== core ===

==== caps ====

 * need way to handle e.g. width=[16,1024] with multiples of 8, or at least make e.g. videoscale ! videoenc negotiate right in cases like that
 * need way to make clear whether a codec is strictly fixed framerate or not, so people don't feed e.g. variable framerate video into theoraenc (or just make those do what videorate does automagically behind the scenes?)
 * Make GstStructure and GstCaps 100% opaque, so we can change the implementation details
 * maybe even internalise the GValue usage and provide explicit API to get/set structure fields:
   * more discoverable, less confusing (GValue seems to confuse people in a caps/structure context)
   * in practice we only allow/handle a few selected types, so may just as well make that more explicit, and the API nicer
   * can keep using GValue internally, but are free to change the implementation if something better comes along (e.g. GVariant, or something home-grown)

==== buffers ====

see [[http://cgit.freedesktop.org/gstreamer/gstreamer/tree/docs/design/draft-buffer2.txt|gstreamer/docs/design/draft-buffer2.txt]]

==== events/messages/queries ====

 * subclass the various types
   * allows to get rid of the extra {event,message,query}-type field
     ''(tpm: not so sure we want that, switch/case on type constants is cheap, comparing GTypes not so much)''
   * static items (flush-event, qos-message} can have explicit member fields
   * most gst_xxx_parse methods can be dropped/deprecated
   * main benefit is that we get a new instance with a single g_slice_new call, instead of 2 g_slice_new + 1 malloc as it is now.
     ''(tpm: that can be solved differently, e.g. by allowing static/embedded GstStructures, or just using GVariant, or somesuch)''

==== registry ====

 * registry API needs to change a bit; we should rely less on structures and hide more things behind accessor API, so that we can better use things like an mmap()ed binary registry (instead of doing lots of parsing and copying all data into memory at startup). GVariant should be useful here.
 * move things over to dynamic types that can be unregistered again?

==== tags ====

 * maybe tag messages/events should work similarly to how eos works, ie. tag readers don't post tags on the bugs themselves, but just send them downstream in form of events and only the sinks post tag messages? This fixes timing problems when tags change mid-stream like with icydemux - if there's buffering between icydemux and the sink the player will get the new tags while the old song is still playing
 * GST_TAG_LANGUAGE_CODE: use ISO-639-2 instead of ISO-639-1. Enforce this. Provide 639-1 => 639-2 table in libgsttag (ideally we'd require iso-codes and provide language_name=>code and code=>language_name functions too).
 * add GST_TAG_LANGUAGE for freeform language description, if setter doesn't know the code
 * we don't really have a way to distinguish transient/non-transient/fixed/non-fixed tags, ie. those which apply to the stream as a whole and are more or less fixed and those that only temporarily apply to the stream or parts of the stream (such as: per-video-frame metadata, current average bitrate for VBR streams etc.); there will be more occasions where we will want to be able to distinguish these and/or choose different delivery mechanisms; posting tag messages 30-times a second may not be ideal, for example
 * API and design for rewriting/filtering tags: pretty hard to do right now, and we don't have API to make a GstTagSetter e.g. remove certain tags (other than reading the tags first and then setting new tags with REPLACE_ALL mode, but that's problematic and inconvenient if you want to change the tags on the fly, since you'd have to hook up event handlers in the streaming thread etc. etc. - it's all either impossible or very inconvenient currently)

==== miscellaneous ====

 * get rid of the abomination that is GstImplementsInterface
   * interfaces should implement a method gst_xxx_is_available() instead (do we need a base iface?)
 * clean up macros in interface headers, should be GST_FO_BAR_GET_INTERFACE, not _GET_IFACE or _GET_CLASS (or at least be consistent); also, interface structures should not be called GstFooBarClass
 * we need to be strict and clear about where URIs are used and where filenames and enforce both
   * uri could be interface property of GstUriHandler
 * need to fix and document assumptions about filename encodings, in accordance with GLib (ie: on win32: should always be utf8, *nix: bunch of bytes, no particular encoding with extras/exceptions)
 * use GstStructure in plugin- and element-descriptions to provide extensibility without breaking things
 * refcount-dependent writability/mutability of buffers/queries/structures is very awkward for language bindings (e.g. C++) 
 * ideally our _new() functions are no more than a thin wrapper around g_object_new() (much better for bindings)
 * get rid of GST_FORMAT_DEFAULT (replace with GST_FORMAT_FRAME or GST_FORMAT_SAMPLE or whatever if need be)
 * Query API: get rid of the whole query-format-may-change thing, it's awkward API and not used anywhere (nor really necessary, is it?)
 * split gst_launch_parse() into separate library, doesn't really need to be in core
 * rewrite parse_launch in C? (if we don't do it now, we'll never be able to do it, since it'll be impossible to rewrite it from scratch and maintain the exact same behaviour; is the current code really maintainable? How many people understand it?)
 * GstBufferClass needs padding
 * GST_STATE_TRANSITION() makes a GstStateChange, rename either of them (probably easier to rename GstStateChange to GstStateTransition, than renaming all the macros).
 * gst_preset_{load|save} should have a GError * argument.
 * add GError * arguments to all synchronous API that may fail, so you get automatic exceptions for bindings (Tim: imho metadata annotation to throw an exception on FALSE/NULL returns would be sufficient, but it was categorically stated that this is the wrong approach and GError is the expected way to report exceptions)
 * Define what codec_data should mean for each format, try to be as consistent as possible.
 * base controller functionality in GstObject, only have the controlsources in a lib
 * unit tests shouldn't use check symbols directly
 * Clean up the GstBus API (add_watch can only be called once), maybe add a return value to "sync-message", etc.. Maybe depcreate add_watch in favor of "message" ?
 * remove unversioned gst-foo? (Causes people problems when debugging with gdb/valgrind, and what's the point in having them if the API / pipeline syntax / element names change from major version to major version, so that they're incompatible between major versions anyway?)
 * remove gst-xmlinspect (people should just use pygst or whatever to inspect the registry)
 * remove gst-xmllaunch
 * libgstcheck: prefix all functions and symbols. Have a wrapping layer that's 100% GStreamer, including environment variables etc.
   * that's just for sanity, check's symbols were mostly exposed by accident
   * magic global symbols aren't very nice API ('buffers')
   * so we can put in another implementation / our own implementation of unit tests instead of using check if we want to

=== gst-plugins-base ===

 * gnomevfssrc/giosrc: default to iradio-mode=true and remove all iradio-* properties (same in souphttpsrc, neonhttpsrc etc.); post iradio tags on the bus
 * application/x-ogm-{video|audio|sub} => audio/x-ogm, video/x-ogm, subtitle/x-ogm
 * fix subparse/subtitle caps to subtitle/x-*
 * fix qtdemux/mp4/m4a/3gp caps detection/typefinding
 * fix ogg typefinding to match new mime/media types

==== libraries ====

 * merge libgstcdda into libgstaudio
 * merge audio bits from libgstinterfaces into libgstaudio
 * merge video bits from libgstinterfaces into libgstvideo
 * change GstPropertyProbe to be more useful and generic and move into core(?). I would be good if a probe could return multiple things, e.g. a "device" probe could return description strings in addition to the various devices found (so we can get rid of the silly device-name thing we do currently)
 * GstMixer is not thread-safe at all; return newly-allocated lists with ref'ed objects etc.; make GstMixerTrack derive from GstObject instead of GObject (so we can lock easily, and set the mixer as parent object); make functions return failure/success

==== miscellaneous ====

 * use consistent parsed/framed field in caps (framed vs. parsed etc.)
 * be stricter about parsed/framed requirements (esp. for decoders), ie. require a parser by default for most framed formats (or just have parser libraries so all plugins can easily parse stuff themselves as and when required)
 * be smarter/more concise about framerates in caps? e.g. when transcoding from a variable frame rate codec to e.g. theora, we should either error out or be able to warn if there's no videorate between decoder+encoder, or theoraenc (and any other encoders that need it) should do the videorate stuff internally (taking into account disconts in the input if needed). Same for audiorate+audio encoders? (see e.g. bug 590859)
 * put more info into caps so it can be negotiated, e.g. the various h264 formats/framings

=== gst-plugins-good ===

 * avoid using sometimes pads in e.g. id3demux, wavparse etc., just set the caps when we have them
